// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: onchainpoker/poker/v1/poker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "onchainpoker.poker.v1";

export enum HandPhase {
  HAND_PHASE_UNSPECIFIED = 0,
  HAND_PHASE_SHUFFLE = 1,
  HAND_PHASE_BETTING = 2,
  HAND_PHASE_AWAIT_FLOP = 3,
  HAND_PHASE_AWAIT_TURN = 4,
  HAND_PHASE_AWAIT_RIVER = 5,
  HAND_PHASE_AWAIT_SHOWDOWN = 6,
  HAND_PHASE_SHOWDOWN = 7,
  UNRECOGNIZED = -1,
}

export function handPhaseFromJSON(object: any): HandPhase {
  switch (object) {
    case 0:
    case "HAND_PHASE_UNSPECIFIED":
      return HandPhase.HAND_PHASE_UNSPECIFIED;
    case 1:
    case "HAND_PHASE_SHUFFLE":
      return HandPhase.HAND_PHASE_SHUFFLE;
    case 2:
    case "HAND_PHASE_BETTING":
      return HandPhase.HAND_PHASE_BETTING;
    case 3:
    case "HAND_PHASE_AWAIT_FLOP":
      return HandPhase.HAND_PHASE_AWAIT_FLOP;
    case 4:
    case "HAND_PHASE_AWAIT_TURN":
      return HandPhase.HAND_PHASE_AWAIT_TURN;
    case 5:
    case "HAND_PHASE_AWAIT_RIVER":
      return HandPhase.HAND_PHASE_AWAIT_RIVER;
    case 6:
    case "HAND_PHASE_AWAIT_SHOWDOWN":
      return HandPhase.HAND_PHASE_AWAIT_SHOWDOWN;
    case 7:
    case "HAND_PHASE_SHOWDOWN":
      return HandPhase.HAND_PHASE_SHOWDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HandPhase.UNRECOGNIZED;
  }
}

export function handPhaseToJSON(object: HandPhase): string {
  switch (object) {
    case HandPhase.HAND_PHASE_UNSPECIFIED:
      return "HAND_PHASE_UNSPECIFIED";
    case HandPhase.HAND_PHASE_SHUFFLE:
      return "HAND_PHASE_SHUFFLE";
    case HandPhase.HAND_PHASE_BETTING:
      return "HAND_PHASE_BETTING";
    case HandPhase.HAND_PHASE_AWAIT_FLOP:
      return "HAND_PHASE_AWAIT_FLOP";
    case HandPhase.HAND_PHASE_AWAIT_TURN:
      return "HAND_PHASE_AWAIT_TURN";
    case HandPhase.HAND_PHASE_AWAIT_RIVER:
      return "HAND_PHASE_AWAIT_RIVER";
    case HandPhase.HAND_PHASE_AWAIT_SHOWDOWN:
      return "HAND_PHASE_AWAIT_SHOWDOWN";
    case HandPhase.HAND_PHASE_SHOWDOWN:
      return "HAND_PHASE_SHOWDOWN";
    case HandPhase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Street {
  STREET_UNSPECIFIED = 0,
  STREET_PREFLOP = 1,
  STREET_FLOP = 2,
  STREET_TURN = 3,
  STREET_RIVER = 4,
  UNRECOGNIZED = -1,
}

export function streetFromJSON(object: any): Street {
  switch (object) {
    case 0:
    case "STREET_UNSPECIFIED":
      return Street.STREET_UNSPECIFIED;
    case 1:
    case "STREET_PREFLOP":
      return Street.STREET_PREFLOP;
    case 2:
    case "STREET_FLOP":
      return Street.STREET_FLOP;
    case 3:
    case "STREET_TURN":
      return Street.STREET_TURN;
    case 4:
    case "STREET_RIVER":
      return Street.STREET_RIVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Street.UNRECOGNIZED;
  }
}

export function streetToJSON(object: Street): string {
  switch (object) {
    case Street.STREET_UNSPECIFIED:
      return "STREET_UNSPECIFIED";
    case Street.STREET_PREFLOP:
      return "STREET_PREFLOP";
    case Street.STREET_FLOP:
      return "STREET_FLOP";
    case Street.STREET_TURN:
      return "STREET_TURN";
    case Street.STREET_RIVER:
      return "STREET_RIVER";
    case Street.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GenesisState defines the x/poker module genesis state. */
export interface GenesisState {
  nextTableId: string;
  tables: Table[];
}

export interface TableParams {
  /** currently only 9 is supported */
  maxPlayers: number;
  smallBlind: string;
  bigBlind: string;
  minBuyIn: string;
  maxBuyIn: string;
  actionTimeoutSecs: string;
  dealerTimeoutSecs: string;
  playerBond: string;
  rakeBps: number;
}

export interface Seat {
  player: string;
  /** 32-byte ristretto point (player DKG key) */
  pk: Uint8Array;
  stack: string;
  bond: string;
  /** Public hole cards (set during showdown reveal). Unknown cards are stored as 0. */
  hole: number[];
}

/**
 * DealerMeta is the minimal dealer state needed by the poker state machine.
 * Encrypted deck/shares are stored in x/dealer.
 */
export interface DealerMeta {
  epochId: string;
  deckSize: number;
  deckFinalized: boolean;
  /**
   * Hole card deck positions for seats, length 18: [seat0_card0, seat0_card1, seat1_card0, ...].
   * Value 255 means unset.
   */
  holePos: number[];
  /** Cursor points to the next board card position in the dealer deck (after hole card assignment). */
  cursor: number;
  /** RevealPos is the currently expected reveal position (255 means "not awaiting"). */
  revealPos: number;
  /** unix seconds */
  revealDeadline: string;
}

export interface Hand {
  handId: string;
  phase: HandPhase;
  street: Street;
  buttonSeat: number;
  smallBlindSeat: number;
  bigBlindSeat: number;
  /** ActionOn is the seat index that must act next, or -1. */
  actionOn: number;
  betTo: string;
  minRaiseSize: string;
  intervalId: string;
  /** Per-seat arrays. Each must have length 9. */
  inHand: boolean[];
  folded: boolean[];
  allIn: boolean[];
  streetCommit: string[];
  totalCommit: string[];
  lastIntervalActed: number[];
  /** Public board cards (card ids 0..51). */
  board: number[];
  /** Poker action timeout. */
  actionDeadline: string;
  /** Dealer integration. */
  dealer: DealerMeta | undefined;
}

export interface Table {
  id: string;
  creator: string;
  label: string;
  params:
    | TableParams
    | undefined;
  /** Fixed-size (9) seats. Empty seats have an empty `player` string. */
  seats: Seat[];
  nextHandId: string;
  buttonSeat: number;
  hand: Hand | undefined;
}

function createBaseGenesisState(): GenesisState {
  return { nextTableId: "0", tables: [] };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextTableId !== "0") {
      writer.uint32(8).uint64(message.nextTableId);
    }
    for (const v of message.tables) {
      Table.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextTableId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tables.push(Table.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      nextTableId: isSet(object.nextTableId)
        ? globalThis.String(object.nextTableId)
        : isSet(object.next_table_id)
        ? globalThis.String(object.next_table_id)
        : "0",
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => Table.fromJSON(e)) : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.nextTableId !== "0") {
      obj.nextTableId = message.nextTableId;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Table.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(base?: I): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(object: I): GenesisState {
    const message = createBaseGenesisState();
    message.nextTableId = object.nextTableId ?? "0";
    message.tables = object.tables?.map((e) => Table.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableParams(): TableParams {
  return {
    maxPlayers: 0,
    smallBlind: "0",
    bigBlind: "0",
    minBuyIn: "0",
    maxBuyIn: "0",
    actionTimeoutSecs: "0",
    dealerTimeoutSecs: "0",
    playerBond: "0",
    rakeBps: 0,
  };
}

export const TableParams: MessageFns<TableParams> = {
  encode(message: TableParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPlayers !== 0) {
      writer.uint32(8).uint32(message.maxPlayers);
    }
    if (message.smallBlind !== "0") {
      writer.uint32(16).uint64(message.smallBlind);
    }
    if (message.bigBlind !== "0") {
      writer.uint32(24).uint64(message.bigBlind);
    }
    if (message.minBuyIn !== "0") {
      writer.uint32(32).uint64(message.minBuyIn);
    }
    if (message.maxBuyIn !== "0") {
      writer.uint32(40).uint64(message.maxBuyIn);
    }
    if (message.actionTimeoutSecs !== "0") {
      writer.uint32(48).uint64(message.actionTimeoutSecs);
    }
    if (message.dealerTimeoutSecs !== "0") {
      writer.uint32(56).uint64(message.dealerTimeoutSecs);
    }
    if (message.playerBond !== "0") {
      writer.uint32(64).uint64(message.playerBond);
    }
    if (message.rakeBps !== 0) {
      writer.uint32(72).uint32(message.rakeBps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxPlayers = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.smallBlind = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bigBlind = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minBuyIn = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxBuyIn = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actionTimeoutSecs = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dealerTimeoutSecs = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.playerBond = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.rakeBps = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableParams {
    return {
      maxPlayers: isSet(object.maxPlayers)
        ? globalThis.Number(object.maxPlayers)
        : isSet(object.max_players)
        ? globalThis.Number(object.max_players)
        : 0,
      smallBlind: isSet(object.smallBlind)
        ? globalThis.String(object.smallBlind)
        : isSet(object.small_blind)
        ? globalThis.String(object.small_blind)
        : "0",
      bigBlind: isSet(object.bigBlind)
        ? globalThis.String(object.bigBlind)
        : isSet(object.big_blind)
        ? globalThis.String(object.big_blind)
        : "0",
      minBuyIn: isSet(object.minBuyIn)
        ? globalThis.String(object.minBuyIn)
        : isSet(object.min_buy_in)
        ? globalThis.String(object.min_buy_in)
        : "0",
      maxBuyIn: isSet(object.maxBuyIn)
        ? globalThis.String(object.maxBuyIn)
        : isSet(object.max_buy_in)
        ? globalThis.String(object.max_buy_in)
        : "0",
      actionTimeoutSecs: isSet(object.actionTimeoutSecs)
        ? globalThis.String(object.actionTimeoutSecs)
        : isSet(object.action_timeout_secs)
        ? globalThis.String(object.action_timeout_secs)
        : "0",
      dealerTimeoutSecs: isSet(object.dealerTimeoutSecs)
        ? globalThis.String(object.dealerTimeoutSecs)
        : isSet(object.dealer_timeout_secs)
        ? globalThis.String(object.dealer_timeout_secs)
        : "0",
      playerBond: isSet(object.playerBond)
        ? globalThis.String(object.playerBond)
        : isSet(object.player_bond)
        ? globalThis.String(object.player_bond)
        : "0",
      rakeBps: isSet(object.rakeBps)
        ? globalThis.Number(object.rakeBps)
        : isSet(object.rake_bps)
        ? globalThis.Number(object.rake_bps)
        : 0,
    };
  },

  toJSON(message: TableParams): unknown {
    const obj: any = {};
    if (message.maxPlayers !== 0) {
      obj.maxPlayers = Math.round(message.maxPlayers);
    }
    if (message.smallBlind !== "0") {
      obj.smallBlind = message.smallBlind;
    }
    if (message.bigBlind !== "0") {
      obj.bigBlind = message.bigBlind;
    }
    if (message.minBuyIn !== "0") {
      obj.minBuyIn = message.minBuyIn;
    }
    if (message.maxBuyIn !== "0") {
      obj.maxBuyIn = message.maxBuyIn;
    }
    if (message.actionTimeoutSecs !== "0") {
      obj.actionTimeoutSecs = message.actionTimeoutSecs;
    }
    if (message.dealerTimeoutSecs !== "0") {
      obj.dealerTimeoutSecs = message.dealerTimeoutSecs;
    }
    if (message.playerBond !== "0") {
      obj.playerBond = message.playerBond;
    }
    if (message.rakeBps !== 0) {
      obj.rakeBps = Math.round(message.rakeBps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TableParams>, I>>(base?: I): TableParams {
    return TableParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TableParams>, I>>(object: I): TableParams {
    const message = createBaseTableParams();
    message.maxPlayers = object.maxPlayers ?? 0;
    message.smallBlind = object.smallBlind ?? "0";
    message.bigBlind = object.bigBlind ?? "0";
    message.minBuyIn = object.minBuyIn ?? "0";
    message.maxBuyIn = object.maxBuyIn ?? "0";
    message.actionTimeoutSecs = object.actionTimeoutSecs ?? "0";
    message.dealerTimeoutSecs = object.dealerTimeoutSecs ?? "0";
    message.playerBond = object.playerBond ?? "0";
    message.rakeBps = object.rakeBps ?? 0;
    return message;
  },
};

function createBaseSeat(): Seat {
  return { player: "", pk: new Uint8Array(0), stack: "0", bond: "0", hole: [] };
}

export const Seat: MessageFns<Seat> = {
  encode(message: Seat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.player !== "") {
      writer.uint32(10).string(message.player);
    }
    if (message.pk.length !== 0) {
      writer.uint32(18).bytes(message.pk);
    }
    if (message.stack !== "0") {
      writer.uint32(24).uint64(message.stack);
    }
    if (message.bond !== "0") {
      writer.uint32(32).uint64(message.bond);
    }
    writer.uint32(42).fork();
    for (const v of message.hole) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pk = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stack = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bond = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.hole.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.hole.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Seat {
    return {
      player: isSet(object.player) ? globalThis.String(object.player) : "",
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
      stack: isSet(object.stack) ? globalThis.String(object.stack) : "0",
      bond: isSet(object.bond) ? globalThis.String(object.bond) : "0",
      hole: globalThis.Array.isArray(object?.hole) ? object.hole.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Seat): unknown {
    const obj: any = {};
    if (message.player !== "") {
      obj.player = message.player;
    }
    if (message.pk.length !== 0) {
      obj.pk = base64FromBytes(message.pk);
    }
    if (message.stack !== "0") {
      obj.stack = message.stack;
    }
    if (message.bond !== "0") {
      obj.bond = message.bond;
    }
    if (message.hole?.length) {
      obj.hole = message.hole.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Seat>, I>>(base?: I): Seat {
    return Seat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Seat>, I>>(object: I): Seat {
    const message = createBaseSeat();
    message.player = object.player ?? "";
    message.pk = object.pk ?? new Uint8Array(0);
    message.stack = object.stack ?? "0";
    message.bond = object.bond ?? "0";
    message.hole = object.hole?.map((e) => e) || [];
    return message;
  },
};

function createBaseDealerMeta(): DealerMeta {
  return { epochId: "0", deckSize: 0, deckFinalized: false, holePos: [], cursor: 0, revealPos: 0, revealDeadline: "0" };
}

export const DealerMeta: MessageFns<DealerMeta> = {
  encode(message: DealerMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.deckSize !== 0) {
      writer.uint32(16).uint32(message.deckSize);
    }
    if (message.deckFinalized !== false) {
      writer.uint32(24).bool(message.deckFinalized);
    }
    writer.uint32(34).fork();
    for (const v of message.holePos) {
      writer.uint32(v);
    }
    writer.join();
    if (message.cursor !== 0) {
      writer.uint32(40).uint32(message.cursor);
    }
    if (message.revealPos !== 0) {
      writer.uint32(48).uint32(message.revealPos);
    }
    if (message.revealDeadline !== "0") {
      writer.uint32(56).int64(message.revealDeadline);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deckSize = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deckFinalized = reader.bool();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.holePos.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.holePos.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cursor = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.revealPos = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.revealDeadline = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerMeta {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      deckSize: isSet(object.deckSize)
        ? globalThis.Number(object.deckSize)
        : isSet(object.deck_size)
        ? globalThis.Number(object.deck_size)
        : 0,
      deckFinalized: isSet(object.deckFinalized)
        ? globalThis.Boolean(object.deckFinalized)
        : isSet(object.deck_finalized)
        ? globalThis.Boolean(object.deck_finalized)
        : false,
      holePos: globalThis.Array.isArray(object?.holePos)
        ? object.holePos.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.hole_pos)
        ? object.hole_pos.map((e: any) => globalThis.Number(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.Number(object.cursor) : 0,
      revealPos: isSet(object.revealPos)
        ? globalThis.Number(object.revealPos)
        : isSet(object.reveal_pos)
        ? globalThis.Number(object.reveal_pos)
        : 0,
      revealDeadline: isSet(object.revealDeadline)
        ? globalThis.String(object.revealDeadline)
        : isSet(object.reveal_deadline)
        ? globalThis.String(object.reveal_deadline)
        : "0",
    };
  },

  toJSON(message: DealerMeta): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.deckSize !== 0) {
      obj.deckSize = Math.round(message.deckSize);
    }
    if (message.deckFinalized !== false) {
      obj.deckFinalized = message.deckFinalized;
    }
    if (message.holePos?.length) {
      obj.holePos = message.holePos.map((e) => Math.round(e));
    }
    if (message.cursor !== 0) {
      obj.cursor = Math.round(message.cursor);
    }
    if (message.revealPos !== 0) {
      obj.revealPos = Math.round(message.revealPos);
    }
    if (message.revealDeadline !== "0") {
      obj.revealDeadline = message.revealDeadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerMeta>, I>>(base?: I): DealerMeta {
    return DealerMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerMeta>, I>>(object: I): DealerMeta {
    const message = createBaseDealerMeta();
    message.epochId = object.epochId ?? "0";
    message.deckSize = object.deckSize ?? 0;
    message.deckFinalized = object.deckFinalized ?? false;
    message.holePos = object.holePos?.map((e) => e) || [];
    message.cursor = object.cursor ?? 0;
    message.revealPos = object.revealPos ?? 0;
    message.revealDeadline = object.revealDeadline ?? "0";
    return message;
  },
};

function createBaseHand(): Hand {
  return {
    handId: "0",
    phase: 0,
    street: 0,
    buttonSeat: 0,
    smallBlindSeat: 0,
    bigBlindSeat: 0,
    actionOn: 0,
    betTo: "0",
    minRaiseSize: "0",
    intervalId: "0",
    inHand: [],
    folded: [],
    allIn: [],
    streetCommit: [],
    totalCommit: [],
    lastIntervalActed: [],
    board: [],
    actionDeadline: "0",
    dealer: undefined,
  };
}

export const Hand: MessageFns<Hand> = {
  encode(message: Hand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handId !== "0") {
      writer.uint32(8).uint64(message.handId);
    }
    if (message.phase !== 0) {
      writer.uint32(16).int32(message.phase);
    }
    if (message.street !== 0) {
      writer.uint32(24).int32(message.street);
    }
    if (message.buttonSeat !== 0) {
      writer.uint32(32).int32(message.buttonSeat);
    }
    if (message.smallBlindSeat !== 0) {
      writer.uint32(40).int32(message.smallBlindSeat);
    }
    if (message.bigBlindSeat !== 0) {
      writer.uint32(48).int32(message.bigBlindSeat);
    }
    if (message.actionOn !== 0) {
      writer.uint32(56).int32(message.actionOn);
    }
    if (message.betTo !== "0") {
      writer.uint32(64).uint64(message.betTo);
    }
    if (message.minRaiseSize !== "0") {
      writer.uint32(72).uint64(message.minRaiseSize);
    }
    if (message.intervalId !== "0") {
      writer.uint32(80).uint64(message.intervalId);
    }
    writer.uint32(90).fork();
    for (const v of message.inHand) {
      writer.bool(v);
    }
    writer.join();
    writer.uint32(98).fork();
    for (const v of message.folded) {
      writer.bool(v);
    }
    writer.join();
    writer.uint32(106).fork();
    for (const v of message.allIn) {
      writer.bool(v);
    }
    writer.join();
    writer.uint32(114).fork();
    for (const v of message.streetCommit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(122).fork();
    for (const v of message.totalCommit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(130).fork();
    for (const v of message.lastIntervalActed) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(138).fork();
    for (const v of message.board) {
      writer.uint32(v);
    }
    writer.join();
    if (message.actionDeadline !== "0") {
      writer.uint32(144).int64(message.actionDeadline);
    }
    if (message.dealer !== undefined) {
      DealerMeta.encode(message.dealer, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.street = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.buttonSeat = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.smallBlindSeat = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.bigBlindSeat = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.actionOn = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.betTo = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.minRaiseSize = reader.uint64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.intervalId = reader.uint64().toString();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.inHand.push(reader.bool());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inHand.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag === 96) {
            message.folded.push(reader.bool());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.folded.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag === 104) {
            message.allIn.push(reader.bool());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allIn.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 14: {
          if (tag === 112) {
            message.streetCommit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.streetCommit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag === 120) {
            message.totalCommit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.totalCommit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 16: {
          if (tag === 128) {
            message.lastIntervalActed.push(reader.int32());

            continue;
          }

          if (tag === 130) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lastIntervalActed.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 17: {
          if (tag === 136) {
            message.board.push(reader.uint32());

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.board.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.actionDeadline = reader.int64().toString();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dealer = DealerMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hand {
    return {
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      phase: isSet(object.phase) ? handPhaseFromJSON(object.phase) : 0,
      street: isSet(object.street) ? streetFromJSON(object.street) : 0,
      buttonSeat: isSet(object.buttonSeat)
        ? globalThis.Number(object.buttonSeat)
        : isSet(object.button_seat)
        ? globalThis.Number(object.button_seat)
        : 0,
      smallBlindSeat: isSet(object.smallBlindSeat)
        ? globalThis.Number(object.smallBlindSeat)
        : isSet(object.small_blind_seat)
        ? globalThis.Number(object.small_blind_seat)
        : 0,
      bigBlindSeat: isSet(object.bigBlindSeat)
        ? globalThis.Number(object.bigBlindSeat)
        : isSet(object.big_blind_seat)
        ? globalThis.Number(object.big_blind_seat)
        : 0,
      actionOn: isSet(object.actionOn)
        ? globalThis.Number(object.actionOn)
        : isSet(object.action_on)
        ? globalThis.Number(object.action_on)
        : 0,
      betTo: isSet(object.betTo)
        ? globalThis.String(object.betTo)
        : isSet(object.bet_to)
        ? globalThis.String(object.bet_to)
        : "0",
      minRaiseSize: isSet(object.minRaiseSize)
        ? globalThis.String(object.minRaiseSize)
        : isSet(object.min_raise_size)
        ? globalThis.String(object.min_raise_size)
        : "0",
      intervalId: isSet(object.intervalId)
        ? globalThis.String(object.intervalId)
        : isSet(object.interval_id)
        ? globalThis.String(object.interval_id)
        : "0",
      inHand: globalThis.Array.isArray(object?.inHand)
        ? object.inHand.map((e: any) => globalThis.Boolean(e))
        : globalThis.Array.isArray(object?.in_hand)
        ? object.in_hand.map((e: any) => globalThis.Boolean(e))
        : [],
      folded: globalThis.Array.isArray(object?.folded)
        ? object.folded.map((e: any) => globalThis.Boolean(e))
        : [],
      allIn: globalThis.Array.isArray(object?.allIn)
        ? object.allIn.map((e: any) => globalThis.Boolean(e))
        : globalThis.Array.isArray(object?.all_in)
        ? object.all_in.map((e: any) => globalThis.Boolean(e))
        : [],
      streetCommit: globalThis.Array.isArray(object?.streetCommit)
        ? object.streetCommit.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.street_commit)
        ? object.street_commit.map((e: any) => globalThis.String(e))
        : [],
      totalCommit: globalThis.Array.isArray(object?.totalCommit)
        ? object.totalCommit.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.total_commit)
        ? object.total_commit.map((e: any) => globalThis.String(e))
        : [],
      lastIntervalActed: globalThis.Array.isArray(object?.lastIntervalActed)
        ? object.lastIntervalActed.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.last_interval_acted)
        ? object.last_interval_acted.map((e: any) => globalThis.Number(e))
        : [],
      board: globalThis.Array.isArray(object?.board)
        ? object.board.map((e: any) => globalThis.Number(e))
        : [],
      actionDeadline: isSet(object.actionDeadline)
        ? globalThis.String(object.actionDeadline)
        : isSet(object.action_deadline)
        ? globalThis.String(object.action_deadline)
        : "0",
      dealer: isSet(object.dealer) ? DealerMeta.fromJSON(object.dealer) : undefined,
    };
  },

  toJSON(message: Hand): unknown {
    const obj: any = {};
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.phase !== 0) {
      obj.phase = handPhaseToJSON(message.phase);
    }
    if (message.street !== 0) {
      obj.street = streetToJSON(message.street);
    }
    if (message.buttonSeat !== 0) {
      obj.buttonSeat = Math.round(message.buttonSeat);
    }
    if (message.smallBlindSeat !== 0) {
      obj.smallBlindSeat = Math.round(message.smallBlindSeat);
    }
    if (message.bigBlindSeat !== 0) {
      obj.bigBlindSeat = Math.round(message.bigBlindSeat);
    }
    if (message.actionOn !== 0) {
      obj.actionOn = Math.round(message.actionOn);
    }
    if (message.betTo !== "0") {
      obj.betTo = message.betTo;
    }
    if (message.minRaiseSize !== "0") {
      obj.minRaiseSize = message.minRaiseSize;
    }
    if (message.intervalId !== "0") {
      obj.intervalId = message.intervalId;
    }
    if (message.inHand?.length) {
      obj.inHand = message.inHand;
    }
    if (message.folded?.length) {
      obj.folded = message.folded;
    }
    if (message.allIn?.length) {
      obj.allIn = message.allIn;
    }
    if (message.streetCommit?.length) {
      obj.streetCommit = message.streetCommit;
    }
    if (message.totalCommit?.length) {
      obj.totalCommit = message.totalCommit;
    }
    if (message.lastIntervalActed?.length) {
      obj.lastIntervalActed = message.lastIntervalActed.map((e) => Math.round(e));
    }
    if (message.board?.length) {
      obj.board = message.board.map((e) => Math.round(e));
    }
    if (message.actionDeadline !== "0") {
      obj.actionDeadline = message.actionDeadline;
    }
    if (message.dealer !== undefined) {
      obj.dealer = DealerMeta.toJSON(message.dealer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hand>, I>>(base?: I): Hand {
    return Hand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hand>, I>>(object: I): Hand {
    const message = createBaseHand();
    message.handId = object.handId ?? "0";
    message.phase = object.phase ?? 0;
    message.street = object.street ?? 0;
    message.buttonSeat = object.buttonSeat ?? 0;
    message.smallBlindSeat = object.smallBlindSeat ?? 0;
    message.bigBlindSeat = object.bigBlindSeat ?? 0;
    message.actionOn = object.actionOn ?? 0;
    message.betTo = object.betTo ?? "0";
    message.minRaiseSize = object.minRaiseSize ?? "0";
    message.intervalId = object.intervalId ?? "0";
    message.inHand = object.inHand?.map((e) => e) || [];
    message.folded = object.folded?.map((e) => e) || [];
    message.allIn = object.allIn?.map((e) => e) || [];
    message.streetCommit = object.streetCommit?.map((e) => e) || [];
    message.totalCommit = object.totalCommit?.map((e) => e) || [];
    message.lastIntervalActed = object.lastIntervalActed?.map((e) => e) || [];
    message.board = object.board?.map((e) => e) || [];
    message.actionDeadline = object.actionDeadline ?? "0";
    message.dealer = (object.dealer !== undefined && object.dealer !== null)
      ? DealerMeta.fromPartial(object.dealer)
      : undefined;
    return message;
  },
};

function createBaseTable(): Table {
  return {
    id: "0",
    creator: "",
    label: "",
    params: undefined,
    seats: [],
    nextHandId: "0",
    buttonSeat: 0,
    hand: undefined,
  };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).uint64(message.id);
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.params !== undefined) {
      TableParams.encode(message.params, writer.uint32(34).fork()).join();
    }
    for (const v of message.seats) {
      Seat.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.nextHandId !== "0") {
      writer.uint32(48).uint64(message.nextHandId);
    }
    if (message.buttonSeat !== 0) {
      writer.uint32(56).int32(message.buttonSeat);
    }
    if (message.hand !== undefined) {
      Hand.encode(message.hand, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params = TableParams.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.seats.push(Seat.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nextHandId = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.buttonSeat = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.hand = Hand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      params: isSet(object.params) ? TableParams.fromJSON(object.params) : undefined,
      seats: globalThis.Array.isArray(object?.seats) ? object.seats.map((e: any) => Seat.fromJSON(e)) : [],
      nextHandId: isSet(object.nextHandId)
        ? globalThis.String(object.nextHandId)
        : isSet(object.next_hand_id)
        ? globalThis.String(object.next_hand_id)
        : "0",
      buttonSeat: isSet(object.buttonSeat)
        ? globalThis.Number(object.buttonSeat)
        : isSet(object.button_seat)
        ? globalThis.Number(object.button_seat)
        : 0,
      hand: isSet(object.hand) ? Hand.fromJSON(object.hand) : undefined,
    };
  },

  toJSON(message: Table): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.params !== undefined) {
      obj.params = TableParams.toJSON(message.params);
    }
    if (message.seats?.length) {
      obj.seats = message.seats.map((e) => Seat.toJSON(e));
    }
    if (message.nextHandId !== "0") {
      obj.nextHandId = message.nextHandId;
    }
    if (message.buttonSeat !== 0) {
      obj.buttonSeat = Math.round(message.buttonSeat);
    }
    if (message.hand !== undefined) {
      obj.hand = Hand.toJSON(message.hand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Table>, I>>(base?: I): Table {
    return Table.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Table>, I>>(object: I): Table {
    const message = createBaseTable();
    message.id = object.id ?? "0";
    message.creator = object.creator ?? "";
    message.label = object.label ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? TableParams.fromPartial(object.params)
      : undefined;
    message.seats = object.seats?.map((e) => Seat.fromPartial(e)) || [];
    message.nextHandId = object.nextHandId ?? "0";
    message.buttonSeat = object.buttonSeat ?? 0;
    message.hand = (object.hand !== undefined && object.hand !== null) ? Hand.fromPartial(object.hand) : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
