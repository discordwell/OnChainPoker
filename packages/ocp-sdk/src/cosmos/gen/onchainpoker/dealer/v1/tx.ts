// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: onchainpoker/dealer/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "onchainpoker.dealer.v1";

export interface MsgBeginEpoch {
  caller: string;
  /** If epoch_id is 0, the chain allocates next epoch id deterministically. */
  epochId: string;
  committeeSize: number;
  threshold: number;
  /** Optional randomness input used for deterministic committee sampling (devnet). */
  randEpoch: Uint8Array;
  /** Optional DKG phase durations in blocks. */
  commitBlocks: string;
  complaintBlocks: string;
  revealBlocks: string;
  finalizeBlocks: string;
}

export interface MsgBeginEpochResponse {
}

export interface MsgDkgCommit {
  dealer: string;
  epochId: string;
  commitments: Uint8Array[];
}

export interface MsgDkgCommitResponse {
}

export interface MsgDkgComplaintMissing {
  complainer: string;
  epochId: string;
  dealer: string;
}

export interface MsgDkgComplaintMissingResponse {
}

export interface MsgDkgComplaintInvalid {
  complainer: string;
  epochId: string;
  dealer: string;
  shareMsg: Uint8Array;
}

export interface MsgDkgComplaintInvalidResponse {
}

export interface MsgDkgShareReveal {
  dealer: string;
  epochId: string;
  to: string;
  share: Uint8Array;
}

export interface MsgDkgShareRevealResponse {
}

export interface MsgFinalizeEpoch {
  caller: string;
  epochId: string;
}

export interface MsgFinalizeEpochResponse {
}

export interface MsgDkgTimeout {
  caller: string;
  epochId: string;
}

export interface MsgDkgTimeoutResponse {
}

export interface MsgInitHand {
  caller: string;
  tableId: string;
  handId: string;
  epochId: string;
  /** default 52 */
  deckSize: number;
}

export interface MsgInitHandResponse {
}

export interface MsgSubmitShuffle {
  shuffler: string;
  tableId: string;
  handId: string;
  round: number;
  proofShuffle: Uint8Array;
}

export interface MsgSubmitShuffleResponse {
}

export interface MsgFinalizeDeck {
  caller: string;
  tableId: string;
  handId: string;
}

export interface MsgFinalizeDeckResponse {
}

export interface MsgSubmitPubShare {
  validator: string;
  tableId: string;
  handId: string;
  pos: number;
  pubShare: Uint8Array;
  proofShare: Uint8Array;
}

export interface MsgSubmitPubShareResponse {
}

export interface MsgSubmitEncShare {
  validator: string;
  tableId: string;
  handId: string;
  pos: number;
  pkPlayer: Uint8Array;
  encShare: Uint8Array;
  proofEncShare: Uint8Array;
}

export interface MsgSubmitEncShareResponse {
}

export interface MsgFinalizeReveal {
  caller: string;
  tableId: string;
  handId: string;
  pos: number;
}

export interface MsgFinalizeRevealResponse {
}

export interface MsgTimeout {
  caller: string;
  tableId: string;
  handId: string;
}

export interface MsgTimeoutResponse {
}

function createBaseMsgBeginEpoch(): MsgBeginEpoch {
  return {
    caller: "",
    epochId: "0",
    committeeSize: 0,
    threshold: 0,
    randEpoch: new Uint8Array(0),
    commitBlocks: "0",
    complaintBlocks: "0",
    revealBlocks: "0",
    finalizeBlocks: "0",
  };
}

export const MsgBeginEpoch: MessageFns<MsgBeginEpoch> = {
  encode(message: MsgBeginEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    if (message.committeeSize !== 0) {
      writer.uint32(24).uint32(message.committeeSize);
    }
    if (message.threshold !== 0) {
      writer.uint32(32).uint32(message.threshold);
    }
    if (message.randEpoch.length !== 0) {
      writer.uint32(42).bytes(message.randEpoch);
    }
    if (message.commitBlocks !== "0") {
      writer.uint32(48).uint64(message.commitBlocks);
    }
    if (message.complaintBlocks !== "0") {
      writer.uint32(56).uint64(message.complaintBlocks);
    }
    if (message.revealBlocks !== "0") {
      writer.uint32(64).uint64(message.revealBlocks);
    }
    if (message.finalizeBlocks !== "0") {
      writer.uint32(72).uint64(message.finalizeBlocks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBeginEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBeginEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.committeeSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.randEpoch = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.commitBlocks = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.complaintBlocks = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.revealBlocks = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.finalizeBlocks = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBeginEpoch {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      committeeSize: isSet(object.committeeSize)
        ? globalThis.Number(object.committeeSize)
        : isSet(object.committee_size)
        ? globalThis.Number(object.committee_size)
        : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      randEpoch: isSet(object.randEpoch)
        ? bytesFromBase64(object.randEpoch)
        : isSet(object.rand_epoch)
        ? bytesFromBase64(object.rand_epoch)
        : new Uint8Array(0),
      commitBlocks: isSet(object.commitBlocks)
        ? globalThis.String(object.commitBlocks)
        : isSet(object.commit_blocks)
        ? globalThis.String(object.commit_blocks)
        : "0",
      complaintBlocks: isSet(object.complaintBlocks)
        ? globalThis.String(object.complaintBlocks)
        : isSet(object.complaint_blocks)
        ? globalThis.String(object.complaint_blocks)
        : "0",
      revealBlocks: isSet(object.revealBlocks)
        ? globalThis.String(object.revealBlocks)
        : isSet(object.reveal_blocks)
        ? globalThis.String(object.reveal_blocks)
        : "0",
      finalizeBlocks: isSet(object.finalizeBlocks)
        ? globalThis.String(object.finalizeBlocks)
        : isSet(object.finalize_blocks)
        ? globalThis.String(object.finalize_blocks)
        : "0",
    };
  },

  toJSON(message: MsgBeginEpoch): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.committeeSize !== 0) {
      obj.committeeSize = Math.round(message.committeeSize);
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.randEpoch.length !== 0) {
      obj.randEpoch = base64FromBytes(message.randEpoch);
    }
    if (message.commitBlocks !== "0") {
      obj.commitBlocks = message.commitBlocks;
    }
    if (message.complaintBlocks !== "0") {
      obj.complaintBlocks = message.complaintBlocks;
    }
    if (message.revealBlocks !== "0") {
      obj.revealBlocks = message.revealBlocks;
    }
    if (message.finalizeBlocks !== "0") {
      obj.finalizeBlocks = message.finalizeBlocks;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBeginEpoch>, I>>(base?: I): MsgBeginEpoch {
    return MsgBeginEpoch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBeginEpoch>, I>>(object: I): MsgBeginEpoch {
    const message = createBaseMsgBeginEpoch();
    message.caller = object.caller ?? "";
    message.epochId = object.epochId ?? "0";
    message.committeeSize = object.committeeSize ?? 0;
    message.threshold = object.threshold ?? 0;
    message.randEpoch = object.randEpoch ?? new Uint8Array(0);
    message.commitBlocks = object.commitBlocks ?? "0";
    message.complaintBlocks = object.complaintBlocks ?? "0";
    message.revealBlocks = object.revealBlocks ?? "0";
    message.finalizeBlocks = object.finalizeBlocks ?? "0";
    return message;
  },
};

function createBaseMsgBeginEpochResponse(): MsgBeginEpochResponse {
  return {};
}

export const MsgBeginEpochResponse: MessageFns<MsgBeginEpochResponse> = {
  encode(_: MsgBeginEpochResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBeginEpochResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBeginEpochResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBeginEpochResponse {
    return {};
  },

  toJSON(_: MsgBeginEpochResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBeginEpochResponse>, I>>(base?: I): MsgBeginEpochResponse {
    return MsgBeginEpochResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBeginEpochResponse>, I>>(_: I): MsgBeginEpochResponse {
    const message = createBaseMsgBeginEpochResponse();
    return message;
  },
};

function createBaseMsgDkgCommit(): MsgDkgCommit {
  return { dealer: "", epochId: "0", commitments: [] };
}

export const MsgDkgCommit: MessageFns<MsgDkgCommit> = {
  encode(message: MsgDkgCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dealer !== "") {
      writer.uint32(10).string(message.dealer);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    for (const v of message.commitments) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgCommit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commitments.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDkgCommit {
    return {
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: MsgDkgCommit): unknown {
    const obj: any = {};
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgCommit>, I>>(base?: I): MsgDkgCommit {
    return MsgDkgCommit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgCommit>, I>>(object: I): MsgDkgCommit {
    const message = createBaseMsgDkgCommit();
    message.dealer = object.dealer ?? "";
    message.epochId = object.epochId ?? "0";
    message.commitments = object.commitments?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgDkgCommitResponse(): MsgDkgCommitResponse {
  return {};
}

export const MsgDkgCommitResponse: MessageFns<MsgDkgCommitResponse> = {
  encode(_: MsgDkgCommitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgCommitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDkgCommitResponse {
    return {};
  },

  toJSON(_: MsgDkgCommitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgCommitResponse>, I>>(base?: I): MsgDkgCommitResponse {
    return MsgDkgCommitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgCommitResponse>, I>>(_: I): MsgDkgCommitResponse {
    const message = createBaseMsgDkgCommitResponse();
    return message;
  },
};

function createBaseMsgDkgComplaintMissing(): MsgDkgComplaintMissing {
  return { complainer: "", epochId: "0", dealer: "" };
}

export const MsgDkgComplaintMissing: MessageFns<MsgDkgComplaintMissing> = {
  encode(message: MsgDkgComplaintMissing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.complainer !== "") {
      writer.uint32(10).string(message.complainer);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    if (message.dealer !== "") {
      writer.uint32(26).string(message.dealer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgComplaintMissing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgComplaintMissing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.complainer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDkgComplaintMissing {
    return {
      complainer: isSet(object.complainer) ? globalThis.String(object.complainer) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
    };
  },

  toJSON(message: MsgDkgComplaintMissing): unknown {
    const obj: any = {};
    if (message.complainer !== "") {
      obj.complainer = message.complainer;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgComplaintMissing>, I>>(base?: I): MsgDkgComplaintMissing {
    return MsgDkgComplaintMissing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgComplaintMissing>, I>>(object: I): MsgDkgComplaintMissing {
    const message = createBaseMsgDkgComplaintMissing();
    message.complainer = object.complainer ?? "";
    message.epochId = object.epochId ?? "0";
    message.dealer = object.dealer ?? "";
    return message;
  },
};

function createBaseMsgDkgComplaintMissingResponse(): MsgDkgComplaintMissingResponse {
  return {};
}

export const MsgDkgComplaintMissingResponse: MessageFns<MsgDkgComplaintMissingResponse> = {
  encode(_: MsgDkgComplaintMissingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgComplaintMissingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgComplaintMissingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDkgComplaintMissingResponse {
    return {};
  },

  toJSON(_: MsgDkgComplaintMissingResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgComplaintMissingResponse>, I>>(base?: I): MsgDkgComplaintMissingResponse {
    return MsgDkgComplaintMissingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgComplaintMissingResponse>, I>>(_: I): MsgDkgComplaintMissingResponse {
    const message = createBaseMsgDkgComplaintMissingResponse();
    return message;
  },
};

function createBaseMsgDkgComplaintInvalid(): MsgDkgComplaintInvalid {
  return { complainer: "", epochId: "0", dealer: "", shareMsg: new Uint8Array(0) };
}

export const MsgDkgComplaintInvalid: MessageFns<MsgDkgComplaintInvalid> = {
  encode(message: MsgDkgComplaintInvalid, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.complainer !== "") {
      writer.uint32(10).string(message.complainer);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    if (message.dealer !== "") {
      writer.uint32(26).string(message.dealer);
    }
    if (message.shareMsg.length !== 0) {
      writer.uint32(34).bytes(message.shareMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgComplaintInvalid {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgComplaintInvalid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.complainer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shareMsg = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDkgComplaintInvalid {
    return {
      complainer: isSet(object.complainer) ? globalThis.String(object.complainer) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      shareMsg: isSet(object.shareMsg)
        ? bytesFromBase64(object.shareMsg)
        : isSet(object.share_msg)
        ? bytesFromBase64(object.share_msg)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgDkgComplaintInvalid): unknown {
    const obj: any = {};
    if (message.complainer !== "") {
      obj.complainer = message.complainer;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.shareMsg.length !== 0) {
      obj.shareMsg = base64FromBytes(message.shareMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgComplaintInvalid>, I>>(base?: I): MsgDkgComplaintInvalid {
    return MsgDkgComplaintInvalid.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgComplaintInvalid>, I>>(object: I): MsgDkgComplaintInvalid {
    const message = createBaseMsgDkgComplaintInvalid();
    message.complainer = object.complainer ?? "";
    message.epochId = object.epochId ?? "0";
    message.dealer = object.dealer ?? "";
    message.shareMsg = object.shareMsg ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgDkgComplaintInvalidResponse(): MsgDkgComplaintInvalidResponse {
  return {};
}

export const MsgDkgComplaintInvalidResponse: MessageFns<MsgDkgComplaintInvalidResponse> = {
  encode(_: MsgDkgComplaintInvalidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgComplaintInvalidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgComplaintInvalidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDkgComplaintInvalidResponse {
    return {};
  },

  toJSON(_: MsgDkgComplaintInvalidResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgComplaintInvalidResponse>, I>>(base?: I): MsgDkgComplaintInvalidResponse {
    return MsgDkgComplaintInvalidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgComplaintInvalidResponse>, I>>(_: I): MsgDkgComplaintInvalidResponse {
    const message = createBaseMsgDkgComplaintInvalidResponse();
    return message;
  },
};

function createBaseMsgDkgShareReveal(): MsgDkgShareReveal {
  return { dealer: "", epochId: "0", to: "", share: new Uint8Array(0) };
}

export const MsgDkgShareReveal: MessageFns<MsgDkgShareReveal> = {
  encode(message: MsgDkgShareReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dealer !== "") {
      writer.uint32(10).string(message.dealer);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.share.length !== 0) {
      writer.uint32(34).bytes(message.share);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgShareReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgShareReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.share = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDkgShareReveal {
    return {
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      share: isSet(object.share) ? bytesFromBase64(object.share) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgDkgShareReveal): unknown {
    const obj: any = {};
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.share.length !== 0) {
      obj.share = base64FromBytes(message.share);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgShareReveal>, I>>(base?: I): MsgDkgShareReveal {
    return MsgDkgShareReveal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgShareReveal>, I>>(object: I): MsgDkgShareReveal {
    const message = createBaseMsgDkgShareReveal();
    message.dealer = object.dealer ?? "";
    message.epochId = object.epochId ?? "0";
    message.to = object.to ?? "";
    message.share = object.share ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgDkgShareRevealResponse(): MsgDkgShareRevealResponse {
  return {};
}

export const MsgDkgShareRevealResponse: MessageFns<MsgDkgShareRevealResponse> = {
  encode(_: MsgDkgShareRevealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgShareRevealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgShareRevealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDkgShareRevealResponse {
    return {};
  },

  toJSON(_: MsgDkgShareRevealResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgShareRevealResponse>, I>>(base?: I): MsgDkgShareRevealResponse {
    return MsgDkgShareRevealResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgShareRevealResponse>, I>>(_: I): MsgDkgShareRevealResponse {
    const message = createBaseMsgDkgShareRevealResponse();
    return message;
  },
};

function createBaseMsgFinalizeEpoch(): MsgFinalizeEpoch {
  return { caller: "", epochId: "0" };
}

export const MsgFinalizeEpoch: MessageFns<MsgFinalizeEpoch> = {
  encode(message: MsgFinalizeEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFinalizeEpoch {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
    };
  },

  toJSON(message: MsgFinalizeEpoch): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeEpoch>, I>>(base?: I): MsgFinalizeEpoch {
    return MsgFinalizeEpoch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeEpoch>, I>>(object: I): MsgFinalizeEpoch {
    const message = createBaseMsgFinalizeEpoch();
    message.caller = object.caller ?? "";
    message.epochId = object.epochId ?? "0";
    return message;
  },
};

function createBaseMsgFinalizeEpochResponse(): MsgFinalizeEpochResponse {
  return {};
}

export const MsgFinalizeEpochResponse: MessageFns<MsgFinalizeEpochResponse> = {
  encode(_: MsgFinalizeEpochResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeEpochResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeEpochResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFinalizeEpochResponse {
    return {};
  },

  toJSON(_: MsgFinalizeEpochResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeEpochResponse>, I>>(base?: I): MsgFinalizeEpochResponse {
    return MsgFinalizeEpochResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeEpochResponse>, I>>(_: I): MsgFinalizeEpochResponse {
    const message = createBaseMsgFinalizeEpochResponse();
    return message;
  },
};

function createBaseMsgDkgTimeout(): MsgDkgTimeout {
  return { caller: "", epochId: "0" };
}

export const MsgDkgTimeout: MessageFns<MsgDkgTimeout> = {
  encode(message: MsgDkgTimeout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.epochId !== "0") {
      writer.uint32(16).uint64(message.epochId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgTimeout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgTimeout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDkgTimeout {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
    };
  },

  toJSON(message: MsgDkgTimeout): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgTimeout>, I>>(base?: I): MsgDkgTimeout {
    return MsgDkgTimeout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgTimeout>, I>>(object: I): MsgDkgTimeout {
    const message = createBaseMsgDkgTimeout();
    message.caller = object.caller ?? "";
    message.epochId = object.epochId ?? "0";
    return message;
  },
};

function createBaseMsgDkgTimeoutResponse(): MsgDkgTimeoutResponse {
  return {};
}

export const MsgDkgTimeoutResponse: MessageFns<MsgDkgTimeoutResponse> = {
  encode(_: MsgDkgTimeoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDkgTimeoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDkgTimeoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDkgTimeoutResponse {
    return {};
  },

  toJSON(_: MsgDkgTimeoutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDkgTimeoutResponse>, I>>(base?: I): MsgDkgTimeoutResponse {
    return MsgDkgTimeoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDkgTimeoutResponse>, I>>(_: I): MsgDkgTimeoutResponse {
    const message = createBaseMsgDkgTimeoutResponse();
    return message;
  },
};

function createBaseMsgInitHand(): MsgInitHand {
  return { caller: "", tableId: "0", handId: "0", epochId: "0", deckSize: 0 };
}

export const MsgInitHand: MessageFns<MsgInitHand> = {
  encode(message: MsgInitHand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    if (message.epochId !== "0") {
      writer.uint32(32).uint64(message.epochId);
    }
    if (message.deckSize !== 0) {
      writer.uint32(40).uint32(message.deckSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInitHand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInitHand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deckSize = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInitHand {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      deckSize: isSet(object.deckSize)
        ? globalThis.Number(object.deckSize)
        : isSet(object.deck_size)
        ? globalThis.Number(object.deck_size)
        : 0,
    };
  },

  toJSON(message: MsgInitHand): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.deckSize !== 0) {
      obj.deckSize = Math.round(message.deckSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgInitHand>, I>>(base?: I): MsgInitHand {
    return MsgInitHand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgInitHand>, I>>(object: I): MsgInitHand {
    const message = createBaseMsgInitHand();
    message.caller = object.caller ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    message.epochId = object.epochId ?? "0";
    message.deckSize = object.deckSize ?? 0;
    return message;
  },
};

function createBaseMsgInitHandResponse(): MsgInitHandResponse {
  return {};
}

export const MsgInitHandResponse: MessageFns<MsgInitHandResponse> = {
  encode(_: MsgInitHandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInitHandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInitHandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInitHandResponse {
    return {};
  },

  toJSON(_: MsgInitHandResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgInitHandResponse>, I>>(base?: I): MsgInitHandResponse {
    return MsgInitHandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgInitHandResponse>, I>>(_: I): MsgInitHandResponse {
    const message = createBaseMsgInitHandResponse();
    return message;
  },
};

function createBaseMsgSubmitShuffle(): MsgSubmitShuffle {
  return { shuffler: "", tableId: "0", handId: "0", round: 0, proofShuffle: new Uint8Array(0) };
}

export const MsgSubmitShuffle: MessageFns<MsgSubmitShuffle> = {
  encode(message: MsgSubmitShuffle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shuffler !== "") {
      writer.uint32(10).string(message.shuffler);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    if (message.round !== 0) {
      writer.uint32(32).uint32(message.round);
    }
    if (message.proofShuffle.length !== 0) {
      writer.uint32(42).bytes(message.proofShuffle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitShuffle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitShuffle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shuffler = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.round = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proofShuffle = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitShuffle {
    return {
      shuffler: isSet(object.shuffler) ? globalThis.String(object.shuffler) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      round: isSet(object.round) ? globalThis.Number(object.round) : 0,
      proofShuffle: isSet(object.proofShuffle)
        ? bytesFromBase64(object.proofShuffle)
        : isSet(object.proof_shuffle)
        ? bytesFromBase64(object.proof_shuffle)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgSubmitShuffle): unknown {
    const obj: any = {};
    if (message.shuffler !== "") {
      obj.shuffler = message.shuffler;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.round !== 0) {
      obj.round = Math.round(message.round);
    }
    if (message.proofShuffle.length !== 0) {
      obj.proofShuffle = base64FromBytes(message.proofShuffle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitShuffle>, I>>(base?: I): MsgSubmitShuffle {
    return MsgSubmitShuffle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitShuffle>, I>>(object: I): MsgSubmitShuffle {
    const message = createBaseMsgSubmitShuffle();
    message.shuffler = object.shuffler ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    message.round = object.round ?? 0;
    message.proofShuffle = object.proofShuffle ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgSubmitShuffleResponse(): MsgSubmitShuffleResponse {
  return {};
}

export const MsgSubmitShuffleResponse: MessageFns<MsgSubmitShuffleResponse> = {
  encode(_: MsgSubmitShuffleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitShuffleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitShuffleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitShuffleResponse {
    return {};
  },

  toJSON(_: MsgSubmitShuffleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitShuffleResponse>, I>>(base?: I): MsgSubmitShuffleResponse {
    return MsgSubmitShuffleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitShuffleResponse>, I>>(_: I): MsgSubmitShuffleResponse {
    const message = createBaseMsgSubmitShuffleResponse();
    return message;
  },
};

function createBaseMsgFinalizeDeck(): MsgFinalizeDeck {
  return { caller: "", tableId: "0", handId: "0" };
}

export const MsgFinalizeDeck: MessageFns<MsgFinalizeDeck> = {
  encode(message: MsgFinalizeDeck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeDeck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeDeck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFinalizeDeck {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
    };
  },

  toJSON(message: MsgFinalizeDeck): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeDeck>, I>>(base?: I): MsgFinalizeDeck {
    return MsgFinalizeDeck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeDeck>, I>>(object: I): MsgFinalizeDeck {
    const message = createBaseMsgFinalizeDeck();
    message.caller = object.caller ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    return message;
  },
};

function createBaseMsgFinalizeDeckResponse(): MsgFinalizeDeckResponse {
  return {};
}

export const MsgFinalizeDeckResponse: MessageFns<MsgFinalizeDeckResponse> = {
  encode(_: MsgFinalizeDeckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeDeckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeDeckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFinalizeDeckResponse {
    return {};
  },

  toJSON(_: MsgFinalizeDeckResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeDeckResponse>, I>>(base?: I): MsgFinalizeDeckResponse {
    return MsgFinalizeDeckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeDeckResponse>, I>>(_: I): MsgFinalizeDeckResponse {
    const message = createBaseMsgFinalizeDeckResponse();
    return message;
  },
};

function createBaseMsgSubmitPubShare(): MsgSubmitPubShare {
  return {
    validator: "",
    tableId: "0",
    handId: "0",
    pos: 0,
    pubShare: new Uint8Array(0),
    proofShare: new Uint8Array(0),
  };
}

export const MsgSubmitPubShare: MessageFns<MsgSubmitPubShare> = {
  encode(message: MsgSubmitPubShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    if (message.pos !== 0) {
      writer.uint32(32).uint32(message.pos);
    }
    if (message.pubShare.length !== 0) {
      writer.uint32(42).bytes(message.pubShare);
    }
    if (message.proofShare.length !== 0) {
      writer.uint32(50).bytes(message.proofShare);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitPubShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitPubShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pubShare = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proofShare = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitPubShare {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      pubShare: isSet(object.pubShare)
        ? bytesFromBase64(object.pubShare)
        : isSet(object.pub_share)
        ? bytesFromBase64(object.pub_share)
        : new Uint8Array(0),
      proofShare: isSet(object.proofShare)
        ? bytesFromBase64(object.proofShare)
        : isSet(object.proof_share)
        ? bytesFromBase64(object.proof_share)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgSubmitPubShare): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.pubShare.length !== 0) {
      obj.pubShare = base64FromBytes(message.pubShare);
    }
    if (message.proofShare.length !== 0) {
      obj.proofShare = base64FromBytes(message.proofShare);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitPubShare>, I>>(base?: I): MsgSubmitPubShare {
    return MsgSubmitPubShare.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitPubShare>, I>>(object: I): MsgSubmitPubShare {
    const message = createBaseMsgSubmitPubShare();
    message.validator = object.validator ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    message.pos = object.pos ?? 0;
    message.pubShare = object.pubShare ?? new Uint8Array(0);
    message.proofShare = object.proofShare ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgSubmitPubShareResponse(): MsgSubmitPubShareResponse {
  return {};
}

export const MsgSubmitPubShareResponse: MessageFns<MsgSubmitPubShareResponse> = {
  encode(_: MsgSubmitPubShareResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitPubShareResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitPubShareResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitPubShareResponse {
    return {};
  },

  toJSON(_: MsgSubmitPubShareResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitPubShareResponse>, I>>(base?: I): MsgSubmitPubShareResponse {
    return MsgSubmitPubShareResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitPubShareResponse>, I>>(_: I): MsgSubmitPubShareResponse {
    const message = createBaseMsgSubmitPubShareResponse();
    return message;
  },
};

function createBaseMsgSubmitEncShare(): MsgSubmitEncShare {
  return {
    validator: "",
    tableId: "0",
    handId: "0",
    pos: 0,
    pkPlayer: new Uint8Array(0),
    encShare: new Uint8Array(0),
    proofEncShare: new Uint8Array(0),
  };
}

export const MsgSubmitEncShare: MessageFns<MsgSubmitEncShare> = {
  encode(message: MsgSubmitEncShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    if (message.pos !== 0) {
      writer.uint32(32).uint32(message.pos);
    }
    if (message.pkPlayer.length !== 0) {
      writer.uint32(42).bytes(message.pkPlayer);
    }
    if (message.encShare.length !== 0) {
      writer.uint32(50).bytes(message.encShare);
    }
    if (message.proofEncShare.length !== 0) {
      writer.uint32(58).bytes(message.proofEncShare);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitEncShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitEncShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pkPlayer = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encShare = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.proofEncShare = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitEncShare {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      pkPlayer: isSet(object.pkPlayer)
        ? bytesFromBase64(object.pkPlayer)
        : isSet(object.pk_player)
        ? bytesFromBase64(object.pk_player)
        : new Uint8Array(0),
      encShare: isSet(object.encShare)
        ? bytesFromBase64(object.encShare)
        : isSet(object.enc_share)
        ? bytesFromBase64(object.enc_share)
        : new Uint8Array(0),
      proofEncShare: isSet(object.proofEncShare)
        ? bytesFromBase64(object.proofEncShare)
        : isSet(object.proof_enc_share)
        ? bytesFromBase64(object.proof_enc_share)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgSubmitEncShare): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.pkPlayer.length !== 0) {
      obj.pkPlayer = base64FromBytes(message.pkPlayer);
    }
    if (message.encShare.length !== 0) {
      obj.encShare = base64FromBytes(message.encShare);
    }
    if (message.proofEncShare.length !== 0) {
      obj.proofEncShare = base64FromBytes(message.proofEncShare);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitEncShare>, I>>(base?: I): MsgSubmitEncShare {
    return MsgSubmitEncShare.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitEncShare>, I>>(object: I): MsgSubmitEncShare {
    const message = createBaseMsgSubmitEncShare();
    message.validator = object.validator ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    message.pos = object.pos ?? 0;
    message.pkPlayer = object.pkPlayer ?? new Uint8Array(0);
    message.encShare = object.encShare ?? new Uint8Array(0);
    message.proofEncShare = object.proofEncShare ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgSubmitEncShareResponse(): MsgSubmitEncShareResponse {
  return {};
}

export const MsgSubmitEncShareResponse: MessageFns<MsgSubmitEncShareResponse> = {
  encode(_: MsgSubmitEncShareResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitEncShareResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitEncShareResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubmitEncShareResponse {
    return {};
  },

  toJSON(_: MsgSubmitEncShareResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubmitEncShareResponse>, I>>(base?: I): MsgSubmitEncShareResponse {
    return MsgSubmitEncShareResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubmitEncShareResponse>, I>>(_: I): MsgSubmitEncShareResponse {
    const message = createBaseMsgSubmitEncShareResponse();
    return message;
  },
};

function createBaseMsgFinalizeReveal(): MsgFinalizeReveal {
  return { caller: "", tableId: "0", handId: "0", pos: 0 };
}

export const MsgFinalizeReveal: MessageFns<MsgFinalizeReveal> = {
  encode(message: MsgFinalizeReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    if (message.pos !== 0) {
      writer.uint32(32).uint32(message.pos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFinalizeReveal {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
    };
  },

  toJSON(message: MsgFinalizeReveal): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeReveal>, I>>(base?: I): MsgFinalizeReveal {
    return MsgFinalizeReveal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeReveal>, I>>(object: I): MsgFinalizeReveal {
    const message = createBaseMsgFinalizeReveal();
    message.caller = object.caller ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    message.pos = object.pos ?? 0;
    return message;
  },
};

function createBaseMsgFinalizeRevealResponse(): MsgFinalizeRevealResponse {
  return {};
}

export const MsgFinalizeRevealResponse: MessageFns<MsgFinalizeRevealResponse> = {
  encode(_: MsgFinalizeRevealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeRevealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeRevealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFinalizeRevealResponse {
    return {};
  },

  toJSON(_: MsgFinalizeRevealResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeRevealResponse>, I>>(base?: I): MsgFinalizeRevealResponse {
    return MsgFinalizeRevealResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeRevealResponse>, I>>(_: I): MsgFinalizeRevealResponse {
    const message = createBaseMsgFinalizeRevealResponse();
    return message;
  },
};

function createBaseMsgTimeout(): MsgTimeout {
  return { caller: "", tableId: "0", handId: "0" };
}

export const MsgTimeout: MessageFns<MsgTimeout> = {
  encode(message: MsgTimeout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caller !== "") {
      writer.uint32(10).string(message.caller);
    }
    if (message.tableId !== "0") {
      writer.uint32(16).uint64(message.tableId);
    }
    if (message.handId !== "0") {
      writer.uint32(24).uint64(message.handId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTimeout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTimeout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tableId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTimeout {
    return {
      caller: isSet(object.caller) ? globalThis.String(object.caller) : "",
      tableId: isSet(object.tableId)
        ? globalThis.String(object.tableId)
        : isSet(object.table_id)
        ? globalThis.String(object.table_id)
        : "0",
      handId: isSet(object.handId)
        ? globalThis.String(object.handId)
        : isSet(object.hand_id)
        ? globalThis.String(object.hand_id)
        : "0",
    };
  },

  toJSON(message: MsgTimeout): unknown {
    const obj: any = {};
    if (message.caller !== "") {
      obj.caller = message.caller;
    }
    if (message.tableId !== "0") {
      obj.tableId = message.tableId;
    }
    if (message.handId !== "0") {
      obj.handId = message.handId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTimeout>, I>>(base?: I): MsgTimeout {
    return MsgTimeout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTimeout>, I>>(object: I): MsgTimeout {
    const message = createBaseMsgTimeout();
    message.caller = object.caller ?? "";
    message.tableId = object.tableId ?? "0";
    message.handId = object.handId ?? "0";
    return message;
  },
};

function createBaseMsgTimeoutResponse(): MsgTimeoutResponse {
  return {};
}

export const MsgTimeoutResponse: MessageFns<MsgTimeoutResponse> = {
  encode(_: MsgTimeoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTimeoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTimeoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTimeoutResponse {
    return {};
  },

  toJSON(_: MsgTimeoutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTimeoutResponse>, I>>(base?: I): MsgTimeoutResponse {
    return MsgTimeoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTimeoutResponse>, I>>(_: I): MsgTimeoutResponse {
    const message = createBaseMsgTimeoutResponse();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
