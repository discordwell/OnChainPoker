// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: onchainpoker/dealer/v1/dealer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "onchainpoker.dealer.v1";

export interface GenesisState {
  nextEpochId: string;
  epoch: DealerEpoch | undefined;
  dkg: DealerDKG | undefined;
  params: Params | undefined;
}

/**
 * Params defines the x/dealer module parameters.
 *
 * NOTE: Dealer faults are intended to map to real PoS stake risk:
 * slashing and (optional) jailing of the underlying validator.
 */
export interface Params {
  /** Slash fraction (in basis points, 1 bps = 0.01%) for objective DKG faults. */
  slashBpsDkg: number;
  /** Slash fraction (in basis points, 1 bps = 0.01%) for objective per-hand dealer faults. */
  slashBpsHandDealer: number;
  /** Jail duration (in seconds) for objective DKG faults. */
  jailSecondsDkg: string;
  /** Jail duration (in seconds) for objective per-hand dealer faults. */
  jailSecondsHandDealer: string;
}

export interface DealerMember {
  /** Validator operator address (valoper). */
  validator: string;
  /** Shamir x-coordinate (non-zero). */
  index: number;
  /** 32-byte ristretto point (Y_i), set at epoch finalize. */
  pubShare: Uint8Array;
  /** 32-byte ed25519 consensus pubkey snapshot (for DKG share-msg signatures). */
  consPubkey: Uint8Array;
  /** Consensus power at committee selection time (used for slashing distribution height/power). */
  power: string;
}

export interface DealerEpoch {
  epochId: string;
  threshold: number;
  /** 32-byte ristretto point. */
  pkEpoch: Uint8Array;
  /** sha256 (v0 placeholder) over the accepted transcript view. */
  transcriptRoot: Uint8Array;
  /**
   * Distribution/obligation height captured at committee selection time (typically the DKG start height).
   * Used for slashing so validators cannot evade by unbonding immediately after being selected.
   */
  startHeight: string;
  /** Canonical ordering: lexicographically ascending by validator. */
  slashed: string[];
  members: DealerMember[];
}

export interface DealerDKGCommit {
  dealer: string;
  commitments: Uint8Array[];
}

export interface DealerDKGComplaint {
  epochId: string;
  complainer: string;
  dealer: string;
  /** "missing" | "invalid" */
  kind: string;
  shareMsg: Uint8Array;
}

export interface DealerDKGShareReveal {
  epochId: string;
  dealer: string;
  to: string;
  share: Uint8Array;
}

export interface DealerDKG {
  epochId: string;
  threshold: number;
  members: DealerMember[];
  startHeight: string;
  commitDeadline: string;
  complaintDeadline: string;
  revealDeadline: string;
  finalizeDeadline: string;
  randEpoch: Uint8Array;
  commits: DealerDKGCommit[];
  complaints: DealerDKGComplaint[];
  reveals: DealerDKGShareReveal[];
  slashed: string[];
}

export interface DealerCiphertext {
  c1: Uint8Array;
  c2: Uint8Array;
}

export interface DealerPubShare {
  pos: number;
  validator: string;
  index: number;
  share: Uint8Array;
  proof: Uint8Array;
}

export interface DealerEncShare {
  pos: number;
  validator: string;
  index: number;
  pkPlayer: Uint8Array;
  /** 64 bytes u||v */
  encShare: Uint8Array;
  /** 160 bytes */
  proof: Uint8Array;
}

export interface DealerReveal {
  pos: number;
  /** 0..51 */
  cardId: number;
}

export interface DealerHand {
  epochId: string;
  pkHand: Uint8Array;
  deckSize: number;
  deck: DealerCiphertext[];
  shuffleStep: number;
  finalized: boolean;
  /** unix seconds */
  shuffleDeadline: string;
  /** unix seconds */
  holeSharesDeadline: string;
  pubShares: DealerPubShare[];
  encShares: DealerEncShare[];
  reveals: DealerReveal[];
}

function createBaseGenesisState(): GenesisState {
  return { nextEpochId: "0", epoch: undefined, dkg: undefined, params: undefined };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextEpochId !== "0") {
      writer.uint32(8).uint64(message.nextEpochId);
    }
    if (message.epoch !== undefined) {
      DealerEpoch.encode(message.epoch, writer.uint32(18).fork()).join();
    }
    if (message.dkg !== undefined) {
      DealerDKG.encode(message.dkg, writer.uint32(26).fork()).join();
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextEpochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.epoch = DealerEpoch.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dkg = DealerDKG.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      nextEpochId: isSet(object.nextEpochId)
        ? globalThis.String(object.nextEpochId)
        : isSet(object.next_epoch_id)
        ? globalThis.String(object.next_epoch_id)
        : "0",
      epoch: isSet(object.epoch) ? DealerEpoch.fromJSON(object.epoch) : undefined,
      dkg: isSet(object.dkg) ? DealerDKG.fromJSON(object.dkg) : undefined,
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.nextEpochId !== "0") {
      obj.nextEpochId = message.nextEpochId;
    }
    if (message.epoch !== undefined) {
      obj.epoch = DealerEpoch.toJSON(message.epoch);
    }
    if (message.dkg !== undefined) {
      obj.dkg = DealerDKG.toJSON(message.dkg);
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(base?: I): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(object: I): GenesisState {
    const message = createBaseGenesisState();
    message.nextEpochId = object.nextEpochId ?? "0";
    message.epoch = (object.epoch !== undefined && object.epoch !== null)
      ? DealerEpoch.fromPartial(object.epoch)
      : undefined;
    message.dkg = (object.dkg !== undefined && object.dkg !== null) ? DealerDKG.fromPartial(object.dkg) : undefined;
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseParams(): Params {
  return { slashBpsDkg: 0, slashBpsHandDealer: 0, jailSecondsDkg: "0", jailSecondsHandDealer: "0" };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slashBpsDkg !== 0) {
      writer.uint32(8).uint32(message.slashBpsDkg);
    }
    if (message.slashBpsHandDealer !== 0) {
      writer.uint32(16).uint32(message.slashBpsHandDealer);
    }
    if (message.jailSecondsDkg !== "0") {
      writer.uint32(24).uint64(message.jailSecondsDkg);
    }
    if (message.jailSecondsHandDealer !== "0") {
      writer.uint32(32).uint64(message.jailSecondsHandDealer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slashBpsDkg = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slashBpsHandDealer = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.jailSecondsDkg = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.jailSecondsHandDealer = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      slashBpsDkg: isSet(object.slashBpsDkg)
        ? globalThis.Number(object.slashBpsDkg)
        : isSet(object.slash_bps_dkg)
        ? globalThis.Number(object.slash_bps_dkg)
        : 0,
      slashBpsHandDealer: isSet(object.slashBpsHandDealer)
        ? globalThis.Number(object.slashBpsHandDealer)
        : isSet(object.slash_bps_hand_dealer)
        ? globalThis.Number(object.slash_bps_hand_dealer)
        : 0,
      jailSecondsDkg: isSet(object.jailSecondsDkg)
        ? globalThis.String(object.jailSecondsDkg)
        : isSet(object.jail_seconds_dkg)
        ? globalThis.String(object.jail_seconds_dkg)
        : "0",
      jailSecondsHandDealer: isSet(object.jailSecondsHandDealer)
        ? globalThis.String(object.jailSecondsHandDealer)
        : isSet(object.jail_seconds_hand_dealer)
        ? globalThis.String(object.jail_seconds_hand_dealer)
        : "0",
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.slashBpsDkg !== 0) {
      obj.slashBpsDkg = Math.round(message.slashBpsDkg);
    }
    if (message.slashBpsHandDealer !== 0) {
      obj.slashBpsHandDealer = Math.round(message.slashBpsHandDealer);
    }
    if (message.jailSecondsDkg !== "0") {
      obj.jailSecondsDkg = message.jailSecondsDkg;
    }
    if (message.jailSecondsHandDealer !== "0") {
      obj.jailSecondsHandDealer = message.jailSecondsHandDealer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.slashBpsDkg = object.slashBpsDkg ?? 0;
    message.slashBpsHandDealer = object.slashBpsHandDealer ?? 0;
    message.jailSecondsDkg = object.jailSecondsDkg ?? "0";
    message.jailSecondsHandDealer = object.jailSecondsHandDealer ?? "0";
    return message;
  },
};

function createBaseDealerMember(): DealerMember {
  return { validator: "", index: 0, pubShare: new Uint8Array(0), consPubkey: new Uint8Array(0), power: "0" };
}

export const DealerMember: MessageFns<DealerMember> = {
  encode(message: DealerMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.pubShare.length !== 0) {
      writer.uint32(26).bytes(message.pubShare);
    }
    if (message.consPubkey.length !== 0) {
      writer.uint32(34).bytes(message.consPubkey);
    }
    if (message.power !== "0") {
      writer.uint32(40).int64(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pubShare = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.consPubkey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.power = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerMember {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      pubShare: isSet(object.pubShare)
        ? bytesFromBase64(object.pubShare)
        : isSet(object.pub_share)
        ? bytesFromBase64(object.pub_share)
        : new Uint8Array(0),
      consPubkey: isSet(object.consPubkey)
        ? bytesFromBase64(object.consPubkey)
        : isSet(object.cons_pubkey)
        ? bytesFromBase64(object.cons_pubkey)
        : new Uint8Array(0),
      power: isSet(object.power) ? globalThis.String(object.power) : "0",
    };
  },

  toJSON(message: DealerMember): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.pubShare.length !== 0) {
      obj.pubShare = base64FromBytes(message.pubShare);
    }
    if (message.consPubkey.length !== 0) {
      obj.consPubkey = base64FromBytes(message.consPubkey);
    }
    if (message.power !== "0") {
      obj.power = message.power;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerMember>, I>>(base?: I): DealerMember {
    return DealerMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerMember>, I>>(object: I): DealerMember {
    const message = createBaseDealerMember();
    message.validator = object.validator ?? "";
    message.index = object.index ?? 0;
    message.pubShare = object.pubShare ?? new Uint8Array(0);
    message.consPubkey = object.consPubkey ?? new Uint8Array(0);
    message.power = object.power ?? "0";
    return message;
  },
};

function createBaseDealerEpoch(): DealerEpoch {
  return {
    epochId: "0",
    threshold: 0,
    pkEpoch: new Uint8Array(0),
    transcriptRoot: new Uint8Array(0),
    startHeight: "0",
    slashed: [],
    members: [],
  };
}

export const DealerEpoch: MessageFns<DealerEpoch> = {
  encode(message: DealerEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint32(message.threshold);
    }
    if (message.pkEpoch.length !== 0) {
      writer.uint32(26).bytes(message.pkEpoch);
    }
    if (message.transcriptRoot.length !== 0) {
      writer.uint32(34).bytes(message.transcriptRoot);
    }
    if (message.startHeight !== "0") {
      writer.uint32(56).int64(message.startHeight);
    }
    for (const v of message.slashed) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.members) {
      DealerMember.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pkEpoch = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transcriptRoot = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.startHeight = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slashed.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.members.push(DealerMember.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerEpoch {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      pkEpoch: isSet(object.pkEpoch)
        ? bytesFromBase64(object.pkEpoch)
        : isSet(object.pk_epoch)
        ? bytesFromBase64(object.pk_epoch)
        : new Uint8Array(0),
      transcriptRoot: isSet(object.transcriptRoot)
        ? bytesFromBase64(object.transcriptRoot)
        : isSet(object.transcript_root)
        ? bytesFromBase64(object.transcript_root)
        : new Uint8Array(0),
      startHeight: isSet(object.startHeight)
        ? globalThis.String(object.startHeight)
        : isSet(object.start_height)
        ? globalThis.String(object.start_height)
        : "0",
      slashed: globalThis.Array.isArray(object?.slashed)
        ? object.slashed.map((e: any) => globalThis.String(e))
        : [],
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => DealerMember.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DealerEpoch): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.pkEpoch.length !== 0) {
      obj.pkEpoch = base64FromBytes(message.pkEpoch);
    }
    if (message.transcriptRoot.length !== 0) {
      obj.transcriptRoot = base64FromBytes(message.transcriptRoot);
    }
    if (message.startHeight !== "0") {
      obj.startHeight = message.startHeight;
    }
    if (message.slashed?.length) {
      obj.slashed = message.slashed;
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => DealerMember.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerEpoch>, I>>(base?: I): DealerEpoch {
    return DealerEpoch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerEpoch>, I>>(object: I): DealerEpoch {
    const message = createBaseDealerEpoch();
    message.epochId = object.epochId ?? "0";
    message.threshold = object.threshold ?? 0;
    message.pkEpoch = object.pkEpoch ?? new Uint8Array(0);
    message.transcriptRoot = object.transcriptRoot ?? new Uint8Array(0);
    message.startHeight = object.startHeight ?? "0";
    message.slashed = object.slashed?.map((e) => e) || [];
    message.members = object.members?.map((e) => DealerMember.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDealerDKGCommit(): DealerDKGCommit {
  return { dealer: "", commitments: [] };
}

export const DealerDKGCommit: MessageFns<DealerDKGCommit> = {
  encode(message: DealerDKGCommit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dealer !== "") {
      writer.uint32(10).string(message.dealer);
    }
    for (const v of message.commitments) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerDKGCommit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerDKGCommit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commitments.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerDKGCommit {
    return {
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: DealerDKGCommit): unknown {
    const obj: any = {};
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerDKGCommit>, I>>(base?: I): DealerDKGCommit {
    return DealerDKGCommit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerDKGCommit>, I>>(object: I): DealerDKGCommit {
    const message = createBaseDealerDKGCommit();
    message.dealer = object.dealer ?? "";
    message.commitments = object.commitments?.map((e) => e) || [];
    return message;
  },
};

function createBaseDealerDKGComplaint(): DealerDKGComplaint {
  return { epochId: "0", complainer: "", dealer: "", kind: "", shareMsg: new Uint8Array(0) };
}

export const DealerDKGComplaint: MessageFns<DealerDKGComplaint> = {
  encode(message: DealerDKGComplaint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.complainer !== "") {
      writer.uint32(18).string(message.complainer);
    }
    if (message.dealer !== "") {
      writer.uint32(26).string(message.dealer);
    }
    if (message.kind !== "") {
      writer.uint32(34).string(message.kind);
    }
    if (message.shareMsg.length !== 0) {
      writer.uint32(42).bytes(message.shareMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerDKGComplaint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerDKGComplaint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.complainer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shareMsg = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerDKGComplaint {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      complainer: isSet(object.complainer) ? globalThis.String(object.complainer) : "",
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      shareMsg: isSet(object.shareMsg)
        ? bytesFromBase64(object.shareMsg)
        : isSet(object.share_msg)
        ? bytesFromBase64(object.share_msg)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DealerDKGComplaint): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.complainer !== "") {
      obj.complainer = message.complainer;
    }
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.shareMsg.length !== 0) {
      obj.shareMsg = base64FromBytes(message.shareMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerDKGComplaint>, I>>(base?: I): DealerDKGComplaint {
    return DealerDKGComplaint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerDKGComplaint>, I>>(object: I): DealerDKGComplaint {
    const message = createBaseDealerDKGComplaint();
    message.epochId = object.epochId ?? "0";
    message.complainer = object.complainer ?? "";
    message.dealer = object.dealer ?? "";
    message.kind = object.kind ?? "";
    message.shareMsg = object.shareMsg ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDealerDKGShareReveal(): DealerDKGShareReveal {
  return { epochId: "0", dealer: "", to: "", share: new Uint8Array(0) };
}

export const DealerDKGShareReveal: MessageFns<DealerDKGShareReveal> = {
  encode(message: DealerDKGShareReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.dealer !== "") {
      writer.uint32(18).string(message.dealer);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.share.length !== 0) {
      writer.uint32(34).bytes(message.share);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerDKGShareReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerDKGShareReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dealer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.share = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerDKGShareReveal {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      dealer: isSet(object.dealer) ? globalThis.String(object.dealer) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      share: isSet(object.share) ? bytesFromBase64(object.share) : new Uint8Array(0),
    };
  },

  toJSON(message: DealerDKGShareReveal): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.dealer !== "") {
      obj.dealer = message.dealer;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.share.length !== 0) {
      obj.share = base64FromBytes(message.share);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerDKGShareReveal>, I>>(base?: I): DealerDKGShareReveal {
    return DealerDKGShareReveal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerDKGShareReveal>, I>>(object: I): DealerDKGShareReveal {
    const message = createBaseDealerDKGShareReveal();
    message.epochId = object.epochId ?? "0";
    message.dealer = object.dealer ?? "";
    message.to = object.to ?? "";
    message.share = object.share ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDealerDKG(): DealerDKG {
  return {
    epochId: "0",
    threshold: 0,
    members: [],
    startHeight: "0",
    commitDeadline: "0",
    complaintDeadline: "0",
    revealDeadline: "0",
    finalizeDeadline: "0",
    randEpoch: new Uint8Array(0),
    commits: [],
    complaints: [],
    reveals: [],
    slashed: [],
  };
}

export const DealerDKG: MessageFns<DealerDKG> = {
  encode(message: DealerDKG, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint32(message.threshold);
    }
    for (const v of message.members) {
      DealerMember.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.startHeight !== "0") {
      writer.uint32(32).int64(message.startHeight);
    }
    if (message.commitDeadline !== "0") {
      writer.uint32(40).int64(message.commitDeadline);
    }
    if (message.complaintDeadline !== "0") {
      writer.uint32(48).int64(message.complaintDeadline);
    }
    if (message.revealDeadline !== "0") {
      writer.uint32(56).int64(message.revealDeadline);
    }
    if (message.finalizeDeadline !== "0") {
      writer.uint32(64).int64(message.finalizeDeadline);
    }
    if (message.randEpoch.length !== 0) {
      writer.uint32(74).bytes(message.randEpoch);
    }
    for (const v of message.commits) {
      DealerDKGCommit.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.complaints) {
      DealerDKGComplaint.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.reveals) {
      DealerDKGShareReveal.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.slashed) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerDKG {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerDKG();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.members.push(DealerMember.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startHeight = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.commitDeadline = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.complaintDeadline = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.revealDeadline = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.finalizeDeadline = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.randEpoch = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.commits.push(DealerDKGCommit.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.complaints.push(DealerDKGComplaint.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.reveals.push(DealerDKGShareReveal.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.slashed.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerDKG {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => DealerMember.fromJSON(e))
        : [],
      startHeight: isSet(object.startHeight)
        ? globalThis.String(object.startHeight)
        : isSet(object.start_height)
        ? globalThis.String(object.start_height)
        : "0",
      commitDeadline: isSet(object.commitDeadline)
        ? globalThis.String(object.commitDeadline)
        : isSet(object.commit_deadline)
        ? globalThis.String(object.commit_deadline)
        : "0",
      complaintDeadline: isSet(object.complaintDeadline)
        ? globalThis.String(object.complaintDeadline)
        : isSet(object.complaint_deadline)
        ? globalThis.String(object.complaint_deadline)
        : "0",
      revealDeadline: isSet(object.revealDeadline)
        ? globalThis.String(object.revealDeadline)
        : isSet(object.reveal_deadline)
        ? globalThis.String(object.reveal_deadline)
        : "0",
      finalizeDeadline: isSet(object.finalizeDeadline)
        ? globalThis.String(object.finalizeDeadline)
        : isSet(object.finalize_deadline)
        ? globalThis.String(object.finalize_deadline)
        : "0",
      randEpoch: isSet(object.randEpoch)
        ? bytesFromBase64(object.randEpoch)
        : isSet(object.rand_epoch)
        ? bytesFromBase64(object.rand_epoch)
        : new Uint8Array(0),
      commits: globalThis.Array.isArray(object?.commits)
        ? object.commits.map((e: any) => DealerDKGCommit.fromJSON(e))
        : [],
      complaints: globalThis.Array.isArray(object?.complaints)
        ? object.complaints.map((e: any) => DealerDKGComplaint.fromJSON(e))
        : [],
      reveals: globalThis.Array.isArray(object?.reveals)
        ? object.reveals.map((e: any) => DealerDKGShareReveal.fromJSON(e))
        : [],
      slashed: globalThis.Array.isArray(object?.slashed) ? object.slashed.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DealerDKG): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => DealerMember.toJSON(e));
    }
    if (message.startHeight !== "0") {
      obj.startHeight = message.startHeight;
    }
    if (message.commitDeadline !== "0") {
      obj.commitDeadline = message.commitDeadline;
    }
    if (message.complaintDeadline !== "0") {
      obj.complaintDeadline = message.complaintDeadline;
    }
    if (message.revealDeadline !== "0") {
      obj.revealDeadline = message.revealDeadline;
    }
    if (message.finalizeDeadline !== "0") {
      obj.finalizeDeadline = message.finalizeDeadline;
    }
    if (message.randEpoch.length !== 0) {
      obj.randEpoch = base64FromBytes(message.randEpoch);
    }
    if (message.commits?.length) {
      obj.commits = message.commits.map((e) => DealerDKGCommit.toJSON(e));
    }
    if (message.complaints?.length) {
      obj.complaints = message.complaints.map((e) => DealerDKGComplaint.toJSON(e));
    }
    if (message.reveals?.length) {
      obj.reveals = message.reveals.map((e) => DealerDKGShareReveal.toJSON(e));
    }
    if (message.slashed?.length) {
      obj.slashed = message.slashed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerDKG>, I>>(base?: I): DealerDKG {
    return DealerDKG.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerDKG>, I>>(object: I): DealerDKG {
    const message = createBaseDealerDKG();
    message.epochId = object.epochId ?? "0";
    message.threshold = object.threshold ?? 0;
    message.members = object.members?.map((e) => DealerMember.fromPartial(e)) || [];
    message.startHeight = object.startHeight ?? "0";
    message.commitDeadline = object.commitDeadline ?? "0";
    message.complaintDeadline = object.complaintDeadline ?? "0";
    message.revealDeadline = object.revealDeadline ?? "0";
    message.finalizeDeadline = object.finalizeDeadline ?? "0";
    message.randEpoch = object.randEpoch ?? new Uint8Array(0);
    message.commits = object.commits?.map((e) => DealerDKGCommit.fromPartial(e)) || [];
    message.complaints = object.complaints?.map((e) => DealerDKGComplaint.fromPartial(e)) || [];
    message.reveals = object.reveals?.map((e) => DealerDKGShareReveal.fromPartial(e)) || [];
    message.slashed = object.slashed?.map((e) => e) || [];
    return message;
  },
};

function createBaseDealerCiphertext(): DealerCiphertext {
  return { c1: new Uint8Array(0), c2: new Uint8Array(0) };
}

export const DealerCiphertext: MessageFns<DealerCiphertext> = {
  encode(message: DealerCiphertext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.c1.length !== 0) {
      writer.uint32(10).bytes(message.c1);
    }
    if (message.c2.length !== 0) {
      writer.uint32(18).bytes(message.c2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerCiphertext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerCiphertext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.c1 = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.c2 = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerCiphertext {
    return {
      c1: isSet(object.c1) ? bytesFromBase64(object.c1) : new Uint8Array(0),
      c2: isSet(object.c2) ? bytesFromBase64(object.c2) : new Uint8Array(0),
    };
  },

  toJSON(message: DealerCiphertext): unknown {
    const obj: any = {};
    if (message.c1.length !== 0) {
      obj.c1 = base64FromBytes(message.c1);
    }
    if (message.c2.length !== 0) {
      obj.c2 = base64FromBytes(message.c2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerCiphertext>, I>>(base?: I): DealerCiphertext {
    return DealerCiphertext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerCiphertext>, I>>(object: I): DealerCiphertext {
    const message = createBaseDealerCiphertext();
    message.c1 = object.c1 ?? new Uint8Array(0);
    message.c2 = object.c2 ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDealerPubShare(): DealerPubShare {
  return { pos: 0, validator: "", index: 0, share: new Uint8Array(0), proof: new Uint8Array(0) };
}

export const DealerPubShare: MessageFns<DealerPubShare> = {
  encode(message: DealerPubShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pos !== 0) {
      writer.uint32(8).uint32(message.pos);
    }
    if (message.validator !== "") {
      writer.uint32(18).string(message.validator);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.share.length !== 0) {
      writer.uint32(34).bytes(message.share);
    }
    if (message.proof.length !== 0) {
      writer.uint32(42).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerPubShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerPubShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.share = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerPubShare {
    return {
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      share: isSet(object.share) ? bytesFromBase64(object.share) : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
    };
  },

  toJSON(message: DealerPubShare): unknown {
    const obj: any = {};
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.share.length !== 0) {
      obj.share = base64FromBytes(message.share);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerPubShare>, I>>(base?: I): DealerPubShare {
    return DealerPubShare.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerPubShare>, I>>(object: I): DealerPubShare {
    const message = createBaseDealerPubShare();
    message.pos = object.pos ?? 0;
    message.validator = object.validator ?? "";
    message.index = object.index ?? 0;
    message.share = object.share ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDealerEncShare(): DealerEncShare {
  return {
    pos: 0,
    validator: "",
    index: 0,
    pkPlayer: new Uint8Array(0),
    encShare: new Uint8Array(0),
    proof: new Uint8Array(0),
  };
}

export const DealerEncShare: MessageFns<DealerEncShare> = {
  encode(message: DealerEncShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pos !== 0) {
      writer.uint32(8).uint32(message.pos);
    }
    if (message.validator !== "") {
      writer.uint32(18).string(message.validator);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.pkPlayer.length !== 0) {
      writer.uint32(34).bytes(message.pkPlayer);
    }
    if (message.encShare.length !== 0) {
      writer.uint32(42).bytes(message.encShare);
    }
    if (message.proof.length !== 0) {
      writer.uint32(50).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerEncShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerEncShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pkPlayer = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.encShare = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerEncShare {
    return {
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      pkPlayer: isSet(object.pkPlayer)
        ? bytesFromBase64(object.pkPlayer)
        : isSet(object.pk_player)
        ? bytesFromBase64(object.pk_player)
        : new Uint8Array(0),
      encShare: isSet(object.encShare)
        ? bytesFromBase64(object.encShare)
        : isSet(object.enc_share)
        ? bytesFromBase64(object.enc_share)
        : new Uint8Array(0),
      proof: isSet(object.proof) ? bytesFromBase64(object.proof) : new Uint8Array(0),
    };
  },

  toJSON(message: DealerEncShare): unknown {
    const obj: any = {};
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.pkPlayer.length !== 0) {
      obj.pkPlayer = base64FromBytes(message.pkPlayer);
    }
    if (message.encShare.length !== 0) {
      obj.encShare = base64FromBytes(message.encShare);
    }
    if (message.proof.length !== 0) {
      obj.proof = base64FromBytes(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerEncShare>, I>>(base?: I): DealerEncShare {
    return DealerEncShare.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerEncShare>, I>>(object: I): DealerEncShare {
    const message = createBaseDealerEncShare();
    message.pos = object.pos ?? 0;
    message.validator = object.validator ?? "";
    message.index = object.index ?? 0;
    message.pkPlayer = object.pkPlayer ?? new Uint8Array(0);
    message.encShare = object.encShare ?? new Uint8Array(0);
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDealerReveal(): DealerReveal {
  return { pos: 0, cardId: 0 };
}

export const DealerReveal: MessageFns<DealerReveal> = {
  encode(message: DealerReveal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pos !== 0) {
      writer.uint32(8).uint32(message.pos);
    }
    if (message.cardId !== 0) {
      writer.uint32(16).uint32(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerReveal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pos = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cardId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerReveal {
    return {
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      cardId: isSet(object.cardId)
        ? globalThis.Number(object.cardId)
        : isSet(object.card_id)
        ? globalThis.Number(object.card_id)
        : 0,
    };
  },

  toJSON(message: DealerReveal): unknown {
    const obj: any = {};
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.cardId !== 0) {
      obj.cardId = Math.round(message.cardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerReveal>, I>>(base?: I): DealerReveal {
    return DealerReveal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerReveal>, I>>(object: I): DealerReveal {
    const message = createBaseDealerReveal();
    message.pos = object.pos ?? 0;
    message.cardId = object.cardId ?? 0;
    return message;
  },
};

function createBaseDealerHand(): DealerHand {
  return {
    epochId: "0",
    pkHand: new Uint8Array(0),
    deckSize: 0,
    deck: [],
    shuffleStep: 0,
    finalized: false,
    shuffleDeadline: "0",
    holeSharesDeadline: "0",
    pubShares: [],
    encShares: [],
    reveals: [],
  };
}

export const DealerHand: MessageFns<DealerHand> = {
  encode(message: DealerHand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epochId !== "0") {
      writer.uint32(8).uint64(message.epochId);
    }
    if (message.pkHand.length !== 0) {
      writer.uint32(18).bytes(message.pkHand);
    }
    if (message.deckSize !== 0) {
      writer.uint32(24).uint32(message.deckSize);
    }
    for (const v of message.deck) {
      DealerCiphertext.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.shuffleStep !== 0) {
      writer.uint32(40).uint32(message.shuffleStep);
    }
    if (message.finalized !== false) {
      writer.uint32(48).bool(message.finalized);
    }
    if (message.shuffleDeadline !== "0") {
      writer.uint32(56).int64(message.shuffleDeadline);
    }
    if (message.holeSharesDeadline !== "0") {
      writer.uint32(64).int64(message.holeSharesDeadline);
    }
    for (const v of message.pubShares) {
      DealerPubShare.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.encShares) {
      DealerEncShare.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.reveals) {
      DealerReveal.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DealerHand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDealerHand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pkHand = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deckSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deck.push(DealerCiphertext.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shuffleStep = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shuffleDeadline = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.holeSharesDeadline = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pubShares.push(DealerPubShare.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.encShares.push(DealerEncShare.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.reveals.push(DealerReveal.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DealerHand {
    return {
      epochId: isSet(object.epochId)
        ? globalThis.String(object.epochId)
        : isSet(object.epoch_id)
        ? globalThis.String(object.epoch_id)
        : "0",
      pkHand: isSet(object.pkHand)
        ? bytesFromBase64(object.pkHand)
        : isSet(object.pk_hand)
        ? bytesFromBase64(object.pk_hand)
        : new Uint8Array(0),
      deckSize: isSet(object.deckSize)
        ? globalThis.Number(object.deckSize)
        : isSet(object.deck_size)
        ? globalThis.Number(object.deck_size)
        : 0,
      deck: globalThis.Array.isArray(object?.deck) ? object.deck.map((e: any) => DealerCiphertext.fromJSON(e)) : [],
      shuffleStep: isSet(object.shuffleStep)
        ? globalThis.Number(object.shuffleStep)
        : isSet(object.shuffle_step)
        ? globalThis.Number(object.shuffle_step)
        : 0,
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
      shuffleDeadline: isSet(object.shuffleDeadline)
        ? globalThis.String(object.shuffleDeadline)
        : isSet(object.shuffle_deadline)
        ? globalThis.String(object.shuffle_deadline)
        : "0",
      holeSharesDeadline: isSet(object.holeSharesDeadline)
        ? globalThis.String(object.holeSharesDeadline)
        : isSet(object.hole_shares_deadline)
        ? globalThis.String(object.hole_shares_deadline)
        : "0",
      pubShares: globalThis.Array.isArray(object?.pubShares)
        ? object.pubShares.map((e: any) => DealerPubShare.fromJSON(e))
        : globalThis.Array.isArray(object?.pub_shares)
        ? object.pub_shares.map((e: any) => DealerPubShare.fromJSON(e))
        : [],
      encShares: globalThis.Array.isArray(object?.encShares)
        ? object.encShares.map((e: any) => DealerEncShare.fromJSON(e))
        : globalThis.Array.isArray(object?.enc_shares)
        ? object.enc_shares.map((e: any) => DealerEncShare.fromJSON(e))
        : [],
      reveals: globalThis.Array.isArray(object?.reveals)
        ? object.reveals.map((e: any) => DealerReveal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DealerHand): unknown {
    const obj: any = {};
    if (message.epochId !== "0") {
      obj.epochId = message.epochId;
    }
    if (message.pkHand.length !== 0) {
      obj.pkHand = base64FromBytes(message.pkHand);
    }
    if (message.deckSize !== 0) {
      obj.deckSize = Math.round(message.deckSize);
    }
    if (message.deck?.length) {
      obj.deck = message.deck.map((e) => DealerCiphertext.toJSON(e));
    }
    if (message.shuffleStep !== 0) {
      obj.shuffleStep = Math.round(message.shuffleStep);
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    if (message.shuffleDeadline !== "0") {
      obj.shuffleDeadline = message.shuffleDeadline;
    }
    if (message.holeSharesDeadline !== "0") {
      obj.holeSharesDeadline = message.holeSharesDeadline;
    }
    if (message.pubShares?.length) {
      obj.pubShares = message.pubShares.map((e) => DealerPubShare.toJSON(e));
    }
    if (message.encShares?.length) {
      obj.encShares = message.encShares.map((e) => DealerEncShare.toJSON(e));
    }
    if (message.reveals?.length) {
      obj.reveals = message.reveals.map((e) => DealerReveal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DealerHand>, I>>(base?: I): DealerHand {
    return DealerHand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DealerHand>, I>>(object: I): DealerHand {
    const message = createBaseDealerHand();
    message.epochId = object.epochId ?? "0";
    message.pkHand = object.pkHand ?? new Uint8Array(0);
    message.deckSize = object.deckSize ?? 0;
    message.deck = object.deck?.map((e) => DealerCiphertext.fromPartial(e)) || [];
    message.shuffleStep = object.shuffleStep ?? 0;
    message.finalized = object.finalized ?? false;
    message.shuffleDeadline = object.shuffleDeadline ?? "0";
    message.holeSharesDeadline = object.holeSharesDeadline ?? "0";
    message.pubShares = object.pubShares?.map((e) => DealerPubShare.fromPartial(e)) || [];
    message.encShares = object.encShares?.map((e) => DealerEncShare.fromPartial(e)) || [];
    message.reveals = object.reveals?.map((e) => DealerReveal.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
