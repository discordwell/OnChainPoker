import { spawn } from "node:child_process";
import fs from "node:fs/promises";
import net from "node:net";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

export const SCRIPTS_DIR = path.dirname(fileURLToPath(import.meta.url));
export const ROOT_DIR = path.resolve(SCRIPTS_DIR, "..");

export function log(msg) {
  // eslint-disable-next-line no-console
  console.log(msg);
}

export function spawnInherit(cmd, args, options = {}) {
  return spawn(cmd, args, {
    cwd: options.cwd,
    env: options.env,
    stdio: "inherit",
    shell: false
  });
}

export async function runInherit(cmd, args, options = {}) {
  const child = spawn(cmd, args, {
    cwd: options.cwd,
    env: options.env,
    stdio: "inherit",
    shell: false
  });
  const result = await new Promise((resolve, reject) => {
    child.once("error", reject);
    child.once("close", (code, signal) => resolve({ code, signal }));
  });
  if (result.code !== 0) {
    throw new Error(`Command failed (${result.code ?? "null"}): ${cmd} ${args.join(" ")}`);
  }
  return result;
}

export async function runCapture(cmd, args, options = {}) {
  const child = spawn(cmd, args, {
    cwd: options.cwd,
    env: options.env,
    stdio: ["ignore", "pipe", "pipe"],
    shell: false
  });

  let stdout = "";
  let stderr = "";
  child.stdout.setEncoding("utf8");
  child.stderr.setEncoding("utf8");
  child.stdout.on("data", (chunk) => {
    stdout += chunk;
  });
  child.stderr.on("data", (chunk) => {
    stderr += chunk;
  });

  const result = await new Promise((resolve, reject) => {
    child.once("error", reject);
    child.once("close", (code, signal) => resolve({ code, signal }));
  });
  if (result.code !== 0) {
    const err = new Error(`Command failed (${result.code ?? "null"}): ${cmd} ${args.join(" ")}`);
    // @ts-ignore - attach debug context
    err.stdout = stdout;
    // @ts-ignore - attach debug context
    err.stderr = stderr;
    throw err;
  }
  return { stdout, stderr };
}

export async function isPortOpen({ host, port, timeoutMs = 250 }) {
  return await new Promise((resolve) => {
    const socket = new net.Socket();
    let done = false;

    function finish(ok) {
      if (done) return;
      done = true;
      socket.destroy();
      resolve(ok);
    }

    socket.setTimeout(timeoutMs);
    socket.once("error", () => finish(false));
    socket.once("timeout", () => finish(false));
    socket.connect(port, host, () => finish(true));
  });
}

export async function waitForPortOpen({ host, port, timeoutMs = 20_000, intervalMs = 250 }) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    // eslint-disable-next-line no-await-in-loop
    const ok = await isPortOpen({ host, port });
    if (ok) return;
    // eslint-disable-next-line no-await-in-loop
    await new Promise((r) => setTimeout(r, intervalMs));
  }
  throw new Error(`Timed out waiting for ${host}:${port}`);
}

export async function fileExists(p) {
  try {
    await fs.stat(p);
    return true;
  } catch (e) {
    if (e && typeof e === "object" && "code" in e && e.code === "ENOENT") return false;
    throw e;
  }
}

export async function readJson(p) {
  const raw = await fs.readFile(p, "utf8");
  return JSON.parse(raw);
}

export async function findLatestDeployment({ deploymentsDir, chainId, preferredNetwork }) {
  let names = [];
  try {
    names = await fs.readdir(deploymentsDir);
  } catch (e) {
    if (e && typeof e === "object" && "code" in e && e.code === "ENOENT") return null;
    throw e;
  }

  const suffix = chainId != null ? `-${String(chainId)}.json` : null;
  const candidates = [];
  for (const name of names) {
    if (!name.endsWith(".json")) continue;
    if (suffix && !name.endsWith(suffix)) continue;
    const fullPath = path.join(deploymentsDir, name);
    // eslint-disable-next-line no-await-in-loop
    const st = await fs.stat(fullPath);
    candidates.push({ fullPath, name, mtimeMs: st.mtimeMs });
  }

  candidates.sort((a, b) => b.mtimeMs - a.mtimeMs);
  if (candidates.length === 0) return null;

  if (preferredNetwork) {
    const preferred = candidates.find((c) => c.name.startsWith(`${preferredNetwork}-`));
    if (preferred) return preferred.fullPath;
  }
  return candidates[0].fullPath;
}

export async function writeWebEnvLocal({ webDir, chainId, rpcUrl, tokenAddress, vaultAddress }) {
  const outPath = path.join(webDir, ".env.local");
  const header =
    "# Generated by `pnpm dev` / `pnpm localnet` (WS10). Safe to delete; do not commit.\n";
  const body =
    `VITE_CHAIN_ID=${chainId}\n` +
    `VITE_RPC_URL=${rpcUrl}\n\n` +
    `VITE_TOKEN_ADDRESS=${tokenAddress}\n` +
    `VITE_VAULT_ADDRESS=${vaultAddress}\n`;
  const next = `${header}${body}`;

  const exists = await fileExists(outPath);
  if (exists) {
    const cur = await fs.readFile(outPath, "utf8");
    if (!cur.startsWith(header) && process.env.OCP_FORCE_WRITE_WEB_ENV !== "1") {
      log(
        `[ws10] ${path.relative(ROOT_DIR, outPath)} exists and wasn't generated by scripts; leaving it unchanged (set OCP_FORCE_WRITE_WEB_ENV=1 to overwrite).`
      );
      return { outPath, wrote: false };
    }
  }

  await fs.writeFile(outPath, next, "utf8");
  return { outPath, wrote: true };
}

export function registerShutdown(handler) {
  let called = false;
  async function wrapped(signal) {
    if (called) return;
    called = true;
    try {
      await handler(signal);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      process.exitCode = 1;
    }
  }

  process.once("SIGINT", () => void wrapped("SIGINT"));
  process.once("SIGTERM", () => void wrapped("SIGTERM"));
  process.once("uncaughtException", (err) => {
    // eslint-disable-next-line no-console
    console.error(err);
    process.exitCode = 1;
    void wrapped("uncaughtException");
  });
  process.once("unhandledRejection", (err) => {
    // eslint-disable-next-line no-console
    console.error(err);
    process.exitCode = 1;
    void wrapped("unhandledRejection");
  });
}
